# Step 1
创建一个新的功能包,并且在`--dependencies` 后面添加`std_msgs`，叫做`talker`，在`talker`下的`src`中添加两个`cpp`文件，分别是`subscriptor.cpp`和`publisher.cpp`
完成后，你的 __工作区__ 下的`src`文件结构应该是：
```
src
├── talker
│   ├── CMakeLists.txt
│   ├── include
│   │   └── talker
│   ├── package.xml
│   └── src
│       ├── publisher.cpp
│       └── subscriptor.cpp
└── ···
```

检查你的`pacages.xml`，应该有`<depend>std_msgs</depend>`

# Step 2 接收者节点
在Subscriptor.cpp中添加以下代码
```[c++]
#include <functional>
#include <rclcpp/rclcpp.hpp>
#include <std_msgs/msg/detail/string__struct.hpp>
#include <std_msgs/msg/string.hpp>

class MinimalSubscription : public rclcpp::Node {
public:
  MinimalSubscription() : Node("minimal_subscriber") {
    subscription_ = this->create_subscription<std_msgs::msg::String>(
        "alliance", 10,
        [this](const std_msgs::msg::String msg) { this->topic_callback(msg); });
  }

private:
  void topic_callback(const std_msgs::msg::String msg) const {
    RCLCPP_INFO(this->get_logger(), "I heard: '%s'", msg.data.c_str());
  }

  rclcpp::Subscription<std_msgs::msg::String>::SharedPtr subscription_;
};

int main(int argc, char *argv[]) {
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<MinimalSubscription>());
  rclcpp::shutdown();
  return 0;
}
```

> 请一行一行的进行抄写，以便发现不懂的代码
- `Subscription : public rclcpp::Node`:这是C++中的多态，代表这个类继承自rclcpp::Node，也就是表示这个类也是个Node，但是我们对这个Node特别的实现接收者的功能
- `[this](auto msg) { this->topic_callback(msg);}`：这是一个C++的lambda表达式，它类似于一个函数，方括号中是我们捕获的当前位置的内容，如果没有this，那么后面的this就会报错，圆括号中是我们接受的参数，使用auto简化代码编写，编译器会自动推导出这个位置的参数,在大括号中是我们的函数体，我们调用了编写的回调函数topic_callback，为什么要this-> 是因为lambda表达式不在类中，也就是没有默认的this指针
- `Subscription() : Node("minimal_subscriber")`：它与常见的构造函数不太一样，因为我们的类是多态继承了Node的，因此需要在调用构造函数之前，先构造基类的示例，这一句的意义就是先构造Node，同样的代码也可以进行类中变量的优先构造

## Step 3 发布者节点
在publisher.cpp中加入以下代码
```
#include <rclcpp/rclcpp.hpp>
#include <rclcpp/timer.hpp>
#include <std_msgs/msg/string.hpp>

using namespace std::chrono_literals;

class Publisher : public rclcpp::Node {
public:
  Publisher() : Node("minimal_subscriber") {
    publisher_ = this->create_publisher<std_msgs::msg::String>("alliance", 10);
    timer_ = this->create_wall_timer(500ms, [this] { timer_callback(); });
  }

private:
  void timer_callback() {
    auto message = std_msgs::msg::String();
    message.data = "Hello, world! " + std::to_string(count_++);
    RCLCPP_INFO(this->get_logger(), "Publishing: '%s'", message.data.c_str());
    publisher_->publish(message);
  }
  size_t count_;

  rclcpp::Publisher<std_msgs::msg::String>::SharedPtr publisher_;
  rclcpp::TimerBase::SharedPtr timer_;
};

int main(int argc, char *argv[]) {
  rclcpp::init(argc, argv);
  rclcpp::spin(std::make_shared<Publisher>());
  rclcpp::shutdown();
  return 0;
}
```
之后`colcon build`即可,注意当前目录

### Step 4 同时运行发布者和接受者
首先打开两个终端,都cd到工作区，ros2的进程在不用nohup的情况下与终端绑定

分别进行
```
source /opt/ros/humble/setup.zsh && source install/setup.zsh  
```

在两个终端中分别运行
```
ros2 run <你的包名字> <你的发布者可执行文件名字>
```
和
```
ros2 run <你的包名字> <你的接受者可执行文件名字>
```
如：
```
ros2 run talker publisher
ros2 run talker subscriptor
```